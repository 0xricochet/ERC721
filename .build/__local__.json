{"manifest": "ethpm/3", "sources": {"Tokens.vy": {"checksum": {"algorithm": "md5", "hash": "47abecbf6da7a3dcfdca9958e1fffd15"}, "urls": [], "content": "# @version 0.3.3\n\nfrom vyper.interfaces import ERC165\nfrom vyper.interfaces import ERC721\n\nimplements: ERC165\nimplements: ERC721\n\n# ERC20 Token Metadata\nNAME: constant(String[20]) = \"Token\"\nSYMBOL: constant(String[5]) = \"TKN\"\nTOKENURI: constant(String[100]) = \"\"\n\n############ ERC-165 #############\n# @dev Static list of supported ERC165 interface ids\nSUPPORTED_INTERFACES: constant(bytes4[2]) = [\n    0x01ffc9a7,  # ERC165 interface ID of ERC165\n    0x80ac58cd,  # ERC165 interface ID of ERC721\n]\n\n\n############ ERC-721 #############\n\n# Interface for the contract called by safeTransferFrom()\ninterface ERC721Receiver:\n    def onERC721Received(\n            operator: address,\n            owner: address,\n            tokenId: uint256,\n            data: Bytes[1024]\n        ) -> bytes32: view\n\n# @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n#      created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n#      number of NFTs may be created and assigned without emitting Transfer. At the time of any\n#      transfer, the approved address for that NFT (if any) is reset to none.\n# @param owner Sender of NFT (if address is zero address it indicates token creation).\n# @param receiver Receiver of NFT (if address is zero address it indicates token destruction).\n# @param tokenId The NFT that got transfered.\nevent Transfer:\n    sender: indexed(address)\n    receiver: indexed(address)\n    tokenId: indexed(uint256)\n\n# @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n#      address indicates there is no approved address. When a Transfer event emits, this also\n#      indicates that the approved address for that NFT (if any) is reset to none.\n# @param owner Owner of NFT.\n# @param approved Address that we are approving.\n# @param tokenId NFT which we are approving.\nevent Approval:\n    owner: indexed(address)\n    approved: indexed(address)\n    tokenId: indexed(uint256)\n\n# @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n#      all NFTs of the owner.\n# @param owner Owner of NFT.\n# @param operator Address to which we are setting operator rights.\n# @param approved Status of operator rights(true if operator rights are given and false if\n# revoked).\nevent ApprovalForAll:\n    owner: indexed(address)\n    operator: indexed(address)\n    approved: bool\n\nasset: public(ERC721)\n\nstruct Owner:\n    owner: address  # NOTE: Track ERC721 ownership here\n    blockCreated: uint256\n\n# @dev PortfolioID {keccak(originalOwner + blockCreated)} => Owner\nidToOwner: public(HashMap[uint256, Owner])\n\n# @dev Mapping from owner address to count of their tokens.\nbalanceOf: public(HashMap[address, uint256])\n\n# @dev Mapping from owner address to mapping of operator addresses.\nisApprovedForAll: public(HashMap[address, HashMap[address, bool]])\n\n# @dev Mapping from NFT ID to approved address.\nidToApprovals: public(HashMap[uint256, address])\n\n\n############ ERC-4494 ############\n\n# @dev Mapping of TokenID to nonce values used for ERC4494 signature verification\nnonces: public(HashMap[uint256, uint256])\n\nDOMAIN_SEPARATOR: public(bytes32)\n\nEIP712_DOMAIN_TYPEHASH: constant(bytes32) = keccak256(\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n)\nEIP712_DOMAIN_NAMEHASH: constant(bytes32) = keccak256(\"Owner NFT\")\nEIP712_DOMAIN_VERSIONHASH: constant(bytes32) = keccak256(\"1\")\n\n\n@external\ndef __init__(asset: ERC721):\n    \"\"\"\n    @dev Contract constructor.\n    \"\"\"\n\n    self.asset = asset\n\n    # ERC712 domain separator for ERC4494\n    self.DOMAIN_SEPARATOR = keccak256(\n        _abi_encode(\n            EIP712_DOMAIN_TYPEHASH,\n            EIP712_DOMAIN_NAMEHASH,\n            EIP712_DOMAIN_VERSIONHASH,\n            chain.id,\n            self,\n        )\n    )\n\n# ERC721 Metadata Extension\n@pure\n@external\ndef name() -> String[40]:\n    return NAME\n\n@pure\n@external \ndef symbol() -> String[5]:\n    return SYMBOL\n\n@pure\n@external\ndef tokenURI() -> String[100]:\n    return TOKENURI\n\n@external\ndef setDomainSeparator():\n    \"\"\"\n    @dev Update the domain separator in case of a hardfork where chain ID changes\n    \"\"\"\n    self.DOMAIN_SEPARATOR = keccak256(\n        _abi_encode(\n            EIP712_DOMAIN_TYPEHASH,\n            EIP712_DOMAIN_NAMEHASH,\n            EIP712_DOMAIN_VERSIONHASH,\n            chain.id,\n            self,\n        )\n    )\n\n\n############ ERC-165 #############\n\n@pure\n@external\ndef supportsInterface(interface_id: bytes4) -> bool:\n    \"\"\"\n    @dev Interface identification is specified in ERC-165.\n    @param interface_id Id of the interface\n    \"\"\"\n    return interface_id in SUPPORTED_INTERFACES\n\n\n##### ERC-721 VIEW FUNCTIONS #####\n\n@view\n@external\ndef ownerOf(tokenId: uint256) -> address:\n    \"\"\"\n    @dev Returns the address of the owner of the NFT.\n         Throws if `tokenId` is not a valid NFT.\n    @param tokenId The identifier for an NFT.\n    \"\"\"\n    owner: address = self.idToOwner[tokenId].owner\n    # Throws if `tokenId` is not a valid NFT\n    assert owner != ZERO_ADDRESS\n    return owner\n\n\n@view\n@external\ndef getApproved(tokenId: uint256) -> address:\n    \"\"\"\n    @dev Get the approved address for a single NFT.\n         Throws if `tokenId` is not a valid NFT.\n    @param tokenId ID of the NFT to query the approval of.\n    \"\"\"\n    # Throws if `tokenId` is not a valid NFT\n    assert self.idToOwner[tokenId].owner != ZERO_ADDRESS\n    return self.idToApprovals[tokenId]\n\n\n### TRANSFER FUNCTION HELPERS ###\n\n@view\n@internal\ndef _isApprovedOrOwner(spender: address, tokenId: uint256) -> bool:\n    \"\"\"\n    @dev Returns whether the given spender can transfer a given token ID\n    @param spender address of the spender to query\n    @param tokenId uint256 ID of the token to be transferred\n    @return bool whether the msg.sender is approved for the given token ID,\n        is an operator of the owner, or is the owner of the token\n    \"\"\"\n    owner: address = self.idToOwner[tokenId].owner\n\n    if owner == spender:\n        return True\n\n    if spender == self.idToApprovals[tokenId]:\n        return True\n\n    if (self.isApprovedForAll[owner])[spender]:\n        return True\n\n    return False\n\n\n@internal\ndef _transferFrom(owner: address, receiver: address, tokenId: uint256, sender: address):\n    \"\"\"\n    @dev Exeute transfer of a NFT.\n         Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n         address for thisassert self.idToOwner[tokenId] == owner NFT. (NOTE: `msg.sender` not allowed in private function so pass `_sender`.)\n         Throws if `receiver` is the zero address.\n         Throws if `owner` is not the current owner.\n         Throws if `tokenId` is not a valid NFT.\n    \"\"\"\n    # Check requirements\n    assert self._isApprovedOrOwner(sender, tokenId)\n    assert receiver != ZERO_ADDRESS\n    assert owner != ZERO_ADDRESS\n    assert self.idToOwner[tokenId].owner == owner\n\n    # Reset approvals, if any\n    if self.idToApprovals[tokenId] != ZERO_ADDRESS:\n        self.idToApprovals[tokenId] = ZERO_ADDRESS\n\n    # EIP-4494: increment nonce on transfer for safety\n    self.nonces[tokenId] += 1\n\n    # Change the owner\n    self.idToOwner[tokenId].owner = receiver\n\n    # Change count tracking\n    self.balanceOf[receiver] -= 1\n    self.balanceOf[receiver] += 1\n\n    # Log the transfer\n    log Transfer(owner, receiver, tokenId)\n\n\n@external\ndef transferFrom(owner: address, receiver: address, tokenId: uint256):\n    \"\"\"\n    @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n         address for this NFT.\n         Throws if `owner` is not the current owner.\n         Throws if `receiver` is the zero address.\n         Throws if `tokenId` is not a valid NFT.\n    @notice The caller is responsible to confirm that `receiver` is capable of receiving NFTs or else\n            they maybe be permanently lost.\n    @param owner The current owner of the NFT.\n    @param receiver The new owner.\n    @param tokenId The NFT to transfer.\n    \"\"\"\n    self._transferFrom(owner, receiver, tokenId, msg.sender)\n\n\n@external\ndef safeTransferFrom(\n        owner: address,\n        receiver: address,\n        tokenId: uint256,\n        data: Bytes[1024]=b\"\"\n    ):\n    \"\"\"\n    @dev Transfers the ownership of an NFT from one address to another address.\n         Throws unless `msg.sender` is the current owner, an authorized operator, or the\n         approved address for this NFT.\n         Throws if `owner` is not the current owner.\n         Throws if `receiver` is the zero address.\n         Throws if `tokenId` is not a valid NFT.\n         If `receiver` is a smart contract, it calls `onERC721Received` on `receiver` and throws if\n         the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n         NOTE: bytes4 is represented by bytes32 with padding\n    @param owner The current owner of the NFT.\n    @param receiver The new owner.\n    @param tokenId The NFT to transfer.\n    @param data Additional data with no specified format, sent in call to `receiver`.\n    \"\"\"\n    self._transferFrom(owner, receiver, tokenId, msg.sender)\n    if receiver.is_contract: # check if `receiver` is a contract address\n        returnValue: bytes32 = ERC721Receiver(receiver).onERC721Received(msg.sender, owner, tokenId, data)\n        # Throws if transfer destination is a contract which does not implement 'onERC721Received'\n        assert returnValue == method_id(\"onERC721Received(address,address,uint256,bytes)\", output_type=bytes32)\n\n\n@external\ndef approve(operator: address, tokenId: uint256):\n    \"\"\"\n    @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n         Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n         Throws if `tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n         Throws if `operator` is the current owner. (NOTE: This is not written the EIP)\n    @param operator Address to be approved for the given NFT ID.\n    @param tokenId ID of the token to be approved.\n    \"\"\"\n    # Throws if `tokenId` is not a valid NFT\n    owner: address = self.idToOwner[tokenId].owner\n    assert owner != ZERO_ADDRESS\n\n    # Throws if `operator` is the current owner\n    assert operator != owner\n\n    # Throws if `msg.sender` is not the current owner, or is approved for all actions\n    assert owner == msg.sender or (self.isApprovedForAll[owner])[msg.sender]\n\n    self.idToApprovals[tokenId] = operator\n    log Approval(owner, operator, tokenId)\n\n\n@external\ndef permit(spender: address, tokenId: uint256, deadline: uint256, sig: Bytes[65]) -> bool:\n    \"\"\"\n    @dev Allow a 3rd party to approve a transfer via EIP-721 message\n        Raises if permit has expired\n        Raises if `tokenId` is unowned\n        Raises if permit is not signed by token owner\n        Raises if `nonce` is not the current expected value\n        Raises if `sig` is not a supported signature type\n    @param spender The approved spender of `tokenId` for the permit\n    @param tokenId The token that is being approved\n        NOTE: signer is checked against this token's owner\n    @param deadline The time limit for which the message is valid for\n    @param sig The signature for the message, either in vrs or EIP-2098 form\n    @return bool If the operation is successful\n    \"\"\"\n    # Permit is still valid\n    assert block.timestamp <= deadline\n\n    # Ensure the token is owned by someone\n    owner: address = self.idToOwner[tokenId].owner\n    assert owner != ZERO_ADDRESS\n\n    # Nonce for given token (signer must ensure they use latest)\n    nonce: uint256 = self.nonces[tokenId]\n\n    # Compose EIP-712 message\n    message: bytes32 = keccak256(\n        _abi_encode(\n            0x1901,\n            self.DOMAIN_SEPARATOR,\n            keccak256(\n                _abi_encode(\n                    keccak256(\n                        \"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\"\n                    ),\n                    spender,\n                    tokenId,\n                    nonce,\n                    deadline,\n                )\n            )\n        )\n    )\n\n    # Validate signature\n    v: uint256 = 0\n    r: uint256 = 0\n    s: uint256 = 0\n\n    if len(sig) == 65:\n        # Normal encoded VRS signatures\n        v = convert(slice(sig, 0, 1), uint256)\n        r = convert(slice(sig, 1, 32), uint256)\n        s = convert(slice(sig, 33, 32), uint256)\n\n    elif len(sig) == 64:\n        # EIP-2098 compact signatures\n        r = convert(slice(sig, 0, 32), uint256)\n        v = convert(slice(sig, 33, 1), uint256)\n        s = convert(slice(sig, 34, 31), uint256)\n\n    else:\n        raise  # Other schemes not supported\n\n    # Ensure owner signed permit\n    assert ecrecover(message, v, r, s) == owner\n\n    self.nonces[tokenId] = nonce + 1\n    self.idToApprovals[tokenId] = spender\n\n    return True\n\n\n@external\ndef setApprovalForAll(operator: address, approved: bool):\n    \"\"\"\n    @dev Enables or disables approval for a third party (\"operator\") to manage all of\n         `msg.sender`'s assets. It also emits the ApprovalForAll event.\n    @notice This works even if sender doesn't own any tokens at the time.\n    @param operator Address to add to the set of authorized operators.\n    @param approved True if the operators is approved, false to revoke approval.\n    \"\"\"\n    self.isApprovedForAll[msg.sender][operator] = approved\n    log ApprovalForAll(msg.sender, operator, approved)\n\n\n#### PORTFOLIO MANAGEMENT FUNCTIONS ####\n\n@external\ndef mint() -> uint256:\n    \"\"\"\n    @dev Create a new Owner NFT\n    @notice `tokenId` cannot be owned by someone because of hash production.\n    @return uint256 Computed TokenID of new Portfolio.\n    \"\"\"\n    # Create token\n    tokenId: uint256 = convert(\n        keccak256(\n            concat(\n                convert(msg.sender, bytes32),\n                convert(block.number, bytes32),\n            )\n        ),\n        uint256,\n    )\n\n    assert self.idToOwner[tokenId].owner == ZERO_ADDRESS  # Sanity check\n    self.idToOwner[tokenId] = Owner({\n        owner: msg.sender,\n        blockCreated: block.number,\n    })\n    self.balanceOf[msg.sender] += 1\n\n    return tokenId\n"}}, "contractTypes": {"Tokens": {"contractName": "Tokens", "sourceId": "Tokens.vy", "deploymentBytecode": {"bytecode": "0x6020610cf76000396000518060a01c610cf2576040526040516000557f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f610140527f7cdb71fe8d5a059cd690d94a074487bcd71f2a0d1a84e621167ae16e80d09c21610160527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc661018052466101a052306101c05260a061012052610120805160208201209050600655610c2f6100c2630000000039610c2f6000016300000000f3600436101561000d57610a6c565b60003560e01c34610c2a576306fdde0381186100985760208060805260056040527f546f6b656e0000000000000000000000000000000000000000000000000000006060526040816080018151808252602083016020830181518152505050805180602083010181600003601f163682375050601f19601f8251602001011690509050810190506080f35b6395d89b4181186101185760208060805260036040527f544b4e00000000000000000000000000000000000000000000000000000000006060526040816080018151808252602083016020830181518152505050805180602083010181600003601f163682375050601f19601f8251602001011690509050810190506080f35b633c130d908118610166576020806060526000604052604081606001815180825250805180602083010181600003601f163682375050601f19601f8251602001011690509050810190506060f35b63e69a94bb8118610201577f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f610120527f7cdb71fe8d5a059cd690d94a074487bcd71f2a0d1a84e621167ae16e80d09c21610140527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6610160524661018052306101a05260a061010052610100805160208201209050600655005b6301ffc9a781186102a3576004358060201b610c2a576040526040517f01ffc9a7000000000000000000000000000000000000000000000000000000006080527f80ac58cd0000000000000000000000000000000000000000000000000000000060a052600060605260006002905b60208102608001518318610288576001606052610293565b600101818118610270575b5050606051905060c052602060c0f35b636352211e81186102d2576001600435602052600052604060002054604052600060405114610c2a5760206040f35b63081812fc811861030f576000600160043560205260005260406000205414610c2a57600460043560205260005260406000205460405260206040f35b6323b872dd811861035b576004358060a01c610c2a57610140526024358060a01c610c2a57610160526101405160a0526101605160c05260443560e0523361010052610359610af7565b005b6342842e0e811861037d5760006105a0526105a08051806101805250506103ad565b63b88d4fde81186104a257606435600401610400813511610c2a57803580610180526020820181816101a0375050505b6004358060a01c610c2a57610140526024358060a01c610c2a57610160526101405160a0526101605160c05260443560e05233610100526103ec610af7565b6000610160513b11156104a05763150b7a026105e052608033610600526101405161062052604435610640528061066052806106000161018051808252602082018181836101a060045afa90505050805180602083010181600003601f163682375050601f19601f8251602001011690508101505060206105e06104a46105fc610160515afa610481573d600060003e3d6000fd5b60203d10610c2a576105e0516105c05263150b7a026105c05118610c2a575b005b63095ea7b3811861055f576004358060a01c610c2a576040526001602435602052600052604060002054606052600060605114610c2a5760605160405114610c2a5733606051186104f4576001610515565b60036060516020526000526040600020803360205260005260406000209050545b15610c2a5760405160046024356020526000526040600020556024356040516060517f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560006080a4005b63745a41bc811861082f576004358060a01c610c2a576040526064356004016041813511610c2a578035806060526020820181816080375050506044354211610c2a57600160243560205260005260406000205460e052600060e05114610c2a576005602435602052600052604060002054610100527f19010000000000000000000000000000000000000000000000000000000000006104e052600654610500527f49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad61042052604051610440526024356104605261010051610480526044356104a05260a0610400526104008051602082012090506105205260606104c0526104c0805160208201209050610120526060366101403760416060511861070f57606051600111610c2a576080516101c05260016101a0526101a0602081015181516020036008021c905061014052606051602111610c2a576081516101c05260206101a0526101a0602081015181516020036008021c905061016052606051604111610c2a5760a1516101c05260206101a0526101a0602081015181516020036008021c9050610180526107ae565b6040606051186107a857606051602011610c2a576080516101c05260206101a0526101a0602081015181516020036008021c905061016052606051602211610c2a5760a1516101c05260016101a0526101a0602081015181516020036008021c905061014052606051604111610c2a5760a2516101c052601f6101a0526101a0602081015181516020036008021c9050610180526107ae565b60006000fd5b60e051610120516101a052610140516101c052610160516101e05261018051610200526020600060806101a060015afa5060005118610c2a576101005160018181830110610c2a57808201905090506005602435602052600052604060002055604051600460243560205260005260406000205560016101a05260206101a0f35b63a22cb46581186108ab576004358060a01c610c2a576040526024358060011c610c2a576060526060516003336020526000526040600020806040516020526000526040600020905055604051337f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3160605160805260206080a3005b631249c58b811861093e576000338160e00152602081019050438160e001526020810190508060c05260c090508051602082012090506040526001604051602052600052604060002054610c2a5760016040516020526000526040600020338155436001820155506002336020526000526040600020805460018181830110610c2a578082019050905081555060206040f35b6338d52e0f81186109555760005460405260206040f35b63bfc206ed81186109845760016004356020526000526040600020805460405260018101546060525060406040f35b6370a0823181186109b7576004358060a01c610c2a57604052600260405160205260005260406000205460605260206060f35b63e985e9c58118610a09576004358060a01c610c2a576040526024358060a01c610c2a576060526003604051602052600052604060002080606051602052600052604060002090505460805260206080f35b630f03a7ff8118610a2e57600460043560205260005260406000205460405260206040f35b63141a468c8118610a5357600560043560205260005260406000205460405260206040f35b633644e5158118610a6a5760065460405260206040f35b505b60006000fd5b600160605160205260005260406000205460805260405160805118610a9b576001815250610af5565b600460605160205260005260406000205460405118610abe576001815250610af5565b6003608051602052600052604060002080604051602052600052604060002090505415610aef576001815250610af5565b60008152505b565b6101005160405260e051606052610b0f610120610a72565b6101205115610c2a57600060c05114610c2a57600060a05114610c2a5760a051600160e05160205260005260406000205418610c2a576000600460e05160205260005260406000205414610b71576000600460e0516020526000526040600020555b600560e0516020526000526040600020805460018181830110610c2a578082019050905081555060c051600160e051602052600052604060002055600260c051602052600052604060002080546001808210610c2a5780820390509050815550600260c0516020526000526040600020805460018181830110610c2a578082019050905081555060e05160c05160a0517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef6000610120a4565b600080fd005b600080fd"}, "runtimeBytecode": {"bytecode": "0x600436101561000d57610a6c565b60003560e01c34610c2a576306fdde0381186100985760208060805260056040527f546f6b656e0000000000000000000000000000000000000000000000000000006060526040816080018151808252602083016020830181518152505050805180602083010181600003601f163682375050601f19601f8251602001011690509050810190506080f35b6395d89b4181186101185760208060805260036040527f544b4e00000000000000000000000000000000000000000000000000000000006060526040816080018151808252602083016020830181518152505050805180602083010181600003601f163682375050601f19601f8251602001011690509050810190506080f35b633c130d908118610166576020806060526000604052604081606001815180825250805180602083010181600003601f163682375050601f19601f8251602001011690509050810190506060f35b63e69a94bb8118610201577f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f610120527f7cdb71fe8d5a059cd690d94a074487bcd71f2a0d1a84e621167ae16e80d09c21610140527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6610160524661018052306101a05260a061010052610100805160208201209050600655005b6301ffc9a781186102a3576004358060201b610c2a576040526040517f01ffc9a7000000000000000000000000000000000000000000000000000000006080527f80ac58cd0000000000000000000000000000000000000000000000000000000060a052600060605260006002905b60208102608001518318610288576001606052610293565b600101818118610270575b5050606051905060c052602060c0f35b636352211e81186102d2576001600435602052600052604060002054604052600060405114610c2a5760206040f35b63081812fc811861030f576000600160043560205260005260406000205414610c2a57600460043560205260005260406000205460405260206040f35b6323b872dd811861035b576004358060a01c610c2a57610140526024358060a01c610c2a57610160526101405160a0526101605160c05260443560e0523361010052610359610af7565b005b6342842e0e811861037d5760006105a0526105a08051806101805250506103ad565b63b88d4fde81186104a257606435600401610400813511610c2a57803580610180526020820181816101a0375050505b6004358060a01c610c2a57610140526024358060a01c610c2a57610160526101405160a0526101605160c05260443560e05233610100526103ec610af7565b6000610160513b11156104a05763150b7a026105e052608033610600526101405161062052604435610640528061066052806106000161018051808252602082018181836101a060045afa90505050805180602083010181600003601f163682375050601f19601f8251602001011690508101505060206105e06104a46105fc610160515afa610481573d600060003e3d6000fd5b60203d10610c2a576105e0516105c05263150b7a026105c05118610c2a575b005b63095ea7b3811861055f576004358060a01c610c2a576040526001602435602052600052604060002054606052600060605114610c2a5760605160405114610c2a5733606051186104f4576001610515565b60036060516020526000526040600020803360205260005260406000209050545b15610c2a5760405160046024356020526000526040600020556024356040516060517f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560006080a4005b63745a41bc811861082f576004358060a01c610c2a576040526064356004016041813511610c2a578035806060526020820181816080375050506044354211610c2a57600160243560205260005260406000205460e052600060e05114610c2a576005602435602052600052604060002054610100527f19010000000000000000000000000000000000000000000000000000000000006104e052600654610500527f49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad61042052604051610440526024356104605261010051610480526044356104a05260a0610400526104008051602082012090506105205260606104c0526104c0805160208201209050610120526060366101403760416060511861070f57606051600111610c2a576080516101c05260016101a0526101a0602081015181516020036008021c905061014052606051602111610c2a576081516101c05260206101a0526101a0602081015181516020036008021c905061016052606051604111610c2a5760a1516101c05260206101a0526101a0602081015181516020036008021c9050610180526107ae565b6040606051186107a857606051602011610c2a576080516101c05260206101a0526101a0602081015181516020036008021c905061016052606051602211610c2a5760a1516101c05260016101a0526101a0602081015181516020036008021c905061014052606051604111610c2a5760a2516101c052601f6101a0526101a0602081015181516020036008021c9050610180526107ae565b60006000fd5b60e051610120516101a052610140516101c052610160516101e05261018051610200526020600060806101a060015afa5060005118610c2a576101005160018181830110610c2a57808201905090506005602435602052600052604060002055604051600460243560205260005260406000205560016101a05260206101a0f35b63a22cb46581186108ab576004358060a01c610c2a576040526024358060011c610c2a576060526060516003336020526000526040600020806040516020526000526040600020905055604051337f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3160605160805260206080a3005b631249c58b811861093e576000338160e00152602081019050438160e001526020810190508060c05260c090508051602082012090506040526001604051602052600052604060002054610c2a5760016040516020526000526040600020338155436001820155506002336020526000526040600020805460018181830110610c2a578082019050905081555060206040f35b6338d52e0f81186109555760005460405260206040f35b63bfc206ed81186109845760016004356020526000526040600020805460405260018101546060525060406040f35b6370a0823181186109b7576004358060a01c610c2a57604052600260405160205260005260406000205460605260206060f35b63e985e9c58118610a09576004358060a01c610c2a576040526024358060a01c610c2a576060526003604051602052600052604060002080606051602052600052604060002090505460805260206080f35b630f03a7ff8118610a2e57600460043560205260005260406000205460405260206040f35b63141a468c8118610a5357600560043560205260005260406000205460405260206040f35b633644e5158118610a6a5760065460405260206040f35b505b60006000fd5b600160605160205260005260406000205460805260405160805118610a9b576001815250610af5565b600460605160205260005260406000205460405118610abe576001815250610af5565b6003608051602052600052604060002080604051602052600052604060002090505415610aef576001815250610af5565b60008152505b565b6101005160405260e051606052610b0f610120610a72565b6101205115610c2a57600060c05114610c2a57600060a05114610c2a5760a051600160e05160205260005260406000205418610c2a576000600460e05160205260005260406000205414610b71576000600460e0516020526000526040600020555b600560e0516020526000526040600020805460018181830110610c2a578082019050905081555060c051600160e051602052600052604060002055600260c051602052600052604060002080546001808210610c2a5780820390509050815550600260c0516020526000526040600020805460018181830110610c2a578082019050905081555060e05160c05160a0517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef6000610120a4565b600080fd"}, "abi": [{"type": "event", "name": "Transfer", "inputs": [{"name": "sender", "type": "address", "indexed": true}, {"name": "receiver", "type": "address", "indexed": true}, {"name": "tokenId", "type": "uint256", "indexed": true}], "anonymous": false}, {"type": "event", "name": "Approval", "inputs": [{"name": "owner", "type": "address", "indexed": true}, {"name": "approved", "type": "address", "indexed": true}, {"name": "tokenId", "type": "uint256", "indexed": true}], "anonymous": false}, {"type": "event", "name": "ApprovalForAll", "inputs": [{"name": "owner", "type": "address", "indexed": true}, {"name": "operator", "type": "address", "indexed": true}, {"name": "approved", "type": "bool", "indexed": false}], "anonymous": false}, {"type": "constructor", "stateMutability": "nonpayable", "inputs": [{"name": "asset", "type": "address"}]}, {"type": "function", "name": "name", "stateMutability": "pure", "inputs": [], "outputs": [{"name": "", "type": "string"}]}, {"type": "function", "name": "symbol", "stateMutability": "pure", "inputs": [], "outputs": [{"name": "", "type": "string"}]}, {"type": "function", "name": "tokenURI", "stateMutability": "pure", "inputs": [], "outputs": [{"name": "", "type": "string"}]}, {"type": "function", "name": "setDomainSeparator", "stateMutability": "nonpayable", "inputs": [], "outputs": []}, {"type": "function", "name": "supportsInterface", "stateMutability": "pure", "inputs": [{"name": "interface_id", "type": "bytes4"}], "outputs": [{"name": "", "type": "bool"}]}, {"type": "function", "name": "ownerOf", "stateMutability": "view", "inputs": [{"name": "tokenId", "type": "uint256"}], "outputs": [{"name": "", "type": "address"}]}, {"type": "function", "name": "getApproved", "stateMutability": "view", "inputs": [{"name": "tokenId", "type": "uint256"}], "outputs": [{"name": "", "type": "address"}]}, {"type": "function", "name": "transferFrom", "stateMutability": "nonpayable", "inputs": [{"name": "owner", "type": "address"}, {"name": "receiver", "type": "address"}, {"name": "tokenId", "type": "uint256"}], "outputs": []}, {"type": "function", "name": "safeTransferFrom", "stateMutability": "nonpayable", "inputs": [{"name": "owner", "type": "address"}, {"name": "receiver", "type": "address"}, {"name": "tokenId", "type": "uint256"}], "outputs": []}, {"type": "function", "name": "safeTransferFrom", "stateMutability": "nonpayable", "inputs": [{"name": "owner", "type": "address"}, {"name": "receiver", "type": "address"}, {"name": "tokenId", "type": "uint256"}, {"name": "data", "type": "bytes"}], "outputs": []}, {"type": "function", "name": "approve", "stateMutability": "nonpayable", "inputs": [{"name": "operator", "type": "address"}, {"name": "tokenId", "type": "uint256"}], "outputs": []}, {"type": "function", "name": "permit", "stateMutability": "nonpayable", "inputs": [{"name": "spender", "type": "address"}, {"name": "tokenId", "type": "uint256"}, {"name": "deadline", "type": "uint256"}, {"name": "sig", "type": "bytes"}], "outputs": [{"name": "", "type": "bool"}]}, {"type": "function", "name": "setApprovalForAll", "stateMutability": "nonpayable", "inputs": [{"name": "operator", "type": "address"}, {"name": "approved", "type": "bool"}], "outputs": []}, {"type": "function", "name": "mint", "stateMutability": "nonpayable", "inputs": [], "outputs": [{"name": "", "type": "uint256"}]}, {"type": "function", "name": "asset", "stateMutability": "view", "inputs": [], "outputs": [{"name": "", "type": "address"}]}, {"type": "function", "name": "idToOwner", "stateMutability": "view", "inputs": [{"name": "arg0", "type": "uint256"}], "outputs": [{"name": "", "type": "tuple", "components": [{"name": "owner", "type": "address"}, {"name": "blockCreated", "type": "uint256"}]}]}, {"type": "function", "name": "balanceOf", "stateMutability": "view", "inputs": [{"name": "arg0", "type": "address"}], "outputs": [{"name": "", "type": "uint256"}]}, {"type": "function", "name": "isApprovedForAll", "stateMutability": "view", "inputs": [{"name": "arg0", "type": "address"}, {"name": "arg1", "type": "address"}], "outputs": [{"name": "", "type": "bool"}]}, {"type": "function", "name": "idToApprovals", "stateMutability": "view", "inputs": [{"name": "arg0", "type": "uint256"}], "outputs": [{"name": "", "type": "address"}]}, {"type": "function", "name": "nonces", "stateMutability": "view", "inputs": [{"name": "arg0", "type": "uint256"}], "outputs": [{"name": "", "type": "uint256"}]}, {"type": "function", "name": "DOMAIN_SEPARATOR", "stateMutability": "view", "inputs": [], "outputs": [{"name": "", "type": "bytes32"}]}], "userdoc": {"methods": {"transferFrom(address,address,uint256)": {"notice": "The caller is responsible to confirm that `receiver` is capable of receiving NFTs or else they maybe be permanently lost."}, "setApprovalForAll(address,bool)": {"notice": "This works even if sender doesn't own any tokens at the time."}, "mint()": {"notice": "`tokenId` cannot be owned by someone because of hash production."}}}, "devdoc": {"methods": {"__init__(address)": {"details": "Contract constructor."}, "setDomainSeparator()": {"details": "Update the domain separator in case of a hardfork where chain ID changes"}, "supportsInterface(bytes4)": {"details": "Interface identification is specified in ERC-165.", "params": {"interface_id": "Id of the interface"}}, "ownerOf(uint256)": {"details": "Returns the address of the owner of the NFT. Throws if `tokenId` is not a valid NFT.", "params": {"tokenId": "The identifier for an NFT."}}, "getApproved(uint256)": {"details": "Get the approved address for a single NFT. Throws if `tokenId` is not a valid NFT.", "params": {"tokenId": "ID of the NFT to query the approval of."}}, "transferFrom(address,address,uint256)": {"details": "Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `owner` is not the current owner. Throws if `receiver` is the zero address. Throws if `tokenId` is not a valid NFT.", "params": {"owner": "The current owner of the NFT.", "receiver": "The new owner.", "tokenId": "The NFT to transfer."}}, "safeTransferFrom(address,address,uint256)": {"details": "Transfers the ownership of an NFT from one address to another address. Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `owner` is not the current owner. Throws if `receiver` is the zero address. Throws if `tokenId` is not a valid NFT. If `receiver` is a smart contract, it calls `onERC721Received` on `receiver` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`. NOTE: bytes4 is represented by bytes32 with padding", "params": {"owner": "The current owner of the NFT.", "receiver": "The new owner.", "tokenId": "The NFT to transfer.", "data": "Additional data with no specified format, sent in call to `receiver`."}}, "safeTransferFrom(address,address,uint256,bytes)": {"details": "Transfers the ownership of an NFT from one address to another address. Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `owner` is not the current owner. Throws if `receiver` is the zero address. Throws if `tokenId` is not a valid NFT. If `receiver` is a smart contract, it calls `onERC721Received` on `receiver` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`. NOTE: bytes4 is represented by bytes32 with padding", "params": {"owner": "The current owner of the NFT.", "receiver": "The new owner.", "tokenId": "The NFT to transfer.", "data": "Additional data with no specified format, sent in call to `receiver`."}}, "approve(address,uint256)": {"details": "Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address. Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner. Throws if `tokenId` is not a valid NFT. (NOTE: This is not written the EIP) Throws if `operator` is the current owner. (NOTE: This is not written the EIP)", "params": {"operator": "Address to be approved for the given NFT ID.", "tokenId": "ID of the token to be approved."}}, "permit(address,uint256,uint256,bytes)": {"details": "Allow a 3rd party to approve a transfer via EIP-721 message Raises if permit has expired Raises if `tokenId` is unowned Raises if permit is not signed by token owner Raises if `nonce` is not the current expected value Raises if `sig` is not a supported signature type", "params": {"spender": "The approved spender of `tokenId` for the permit", "tokenId": "The token that is being approved NOTE: signer is checked against this token's owner", "deadline": "The time limit for which the message is valid for", "sig": "The signature for the message, either in vrs or EIP-2098 form"}, "returns": {"_0": "bool If the operation is successful"}}, "setApprovalForAll(address,bool)": {"details": "Enables or disables approval for a third party (\"operator\") to manage all of `msg.sender`'s assets. It also emits the ApprovalForAll event.", "params": {"operator": "Address to add to the set of authorized operators.", "approved": "True if the operators is approved, false to revoke approval."}}, "mint()": {"details": "Create a new Owner NFT", "returns": {"_0": "uint256 Computed TokenID of new Portfolio."}}}}}}}